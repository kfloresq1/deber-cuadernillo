{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "![Título](Images/cisco.png)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Práctica de laboratorio: Realice el desafío de Python \n",
    "\n",
    "\n",
    "Este es un ejercicio opcional para probar su conocimiento de los principios básicos de Python. Sin embargo, recomendamos fervientemente que el estudiante complete estos ejercicios para prepararse para el resto de este curso. Si no sabe cómo resolverlos, fíjese en las lecciones de Python disponibles en la carpeta de Materiales del curso/tutoriales y demostraciones."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Responda las preguntas o complete las tareas detalladas a continuación; utilice el método específico descrito, si corresponde."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### 1) ¿Cuánto es 3 a la potencia de 5?"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "243"
      ]
     },
     "execution_count": 1,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "3**5\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### 2) Cree una variable, *'s'*, que contenga la cadena \"¡Este curso es increíble!\". Con la variable, divida la cadena en una lista."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "['¡Este', 'curso', 'es', 'increíble!']\n"
     ]
    }
   ],
   "source": [
    "# Code cell 2\n",
    "s = \"¡Este curso es increíble!\"\n",
    "print(s.split())\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### 3) Dadas las variables altura y montaña, use .format() para imprimir la cadena siguiente:\n",
    "<center>‘La altura del Monte Everest es de 8848 metros’.</center>"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "La altura del Mt. Everest es de 8848 metros\n"
     ]
    }
   ],
   "source": [
    "# Code cell 3\n",
    "mountain = \"Mt. Everest\"\n",
    "height = 8848\n",
    "print(\"La altura del {} es de {} metros\".format( mountain , height ))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### 4) Dada la lista anidada siguiente, use la indexación para tomar la palabra '\"esto\"'."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 58,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "['this']\n"
     ]
    }
   ],
   "source": [
    "# Code cell 4\n",
    "lst = ['a','b',[4,10,11],['c',[1,66,['this']],2,111],'e',7]\n",
    "print(lst[3][1][2])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### 5) Dado el diccionario anidado siguiente, tome la palabra \"eso\". Este ejercicio es un poco más difícil."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 71,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "that\n"
     ]
    }
   ],
   "source": [
    "# Code cell 5\n",
    "d = {'k1':['val1','val2','val3',{'we':['need','to','go',{'deeper':[1,2,3,'that']}]}]}\n",
    "print(d ['k1'][3]['we'][3]['deeper'][3])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### 6) ¿Cuál es la diferencia principal entre una tupla y una lista? "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": true
   },
   "source": [
    "Una lista no es lo mismo que una tupla. Ambas son un conjunto ordenado de valores, en donde este último puede ser cualquier objeto: un número, una cadena, una función, una clase, una instancia, etc. La diferencia es que las listas presentan una serie de funciones adicionales que permiten un amplio manejo de los valores que contienen. Basándonos en esta definición, puede decirse que las listas son dinámicas, mientras que las tuplas son estáticas."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    " 7) Cree una función, GetDomain(), que tome el dominio del sitio web de correo electrónico de una cadena en la forma: 'user@domain.com'.\n",
    "Por ejemplo, el paso de \"user@domain.com\" daría: domain.com"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 76,
   "metadata": {},
   "outputs": [
    {
     "ename": "TypeError",
     "evalue": "GetDomain() takes 0 positional arguments but 1 was given",
     "output_type": "error",
     "traceback": [
      "\u001b[1;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[1;31mTypeError\u001b[0m                                 Traceback (most recent call last)",
      "\u001b[1;32m<ipython-input-76-dd4693d23dce>\u001b[0m in \u001b[0;36m<module>\u001b[1;34m\u001b[0m\n\u001b[0;32m      2\u001b[0m \u001b[1;32mdef\u001b[0m \u001b[0mGetDomain\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m:\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m      3\u001b[0m    \u001b[1;32mreturn\u001b[0m \u001b[0mGetDomain\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0minput\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mdomain\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mcom\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m[\u001b[0m\u001b[1;33m-\u001b[0m\u001b[1;36m1\u001b[0m\u001b[1;33m]\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m----> 4\u001b[1;33m \u001b[0mprint\u001b[0m\u001b[1;33m(\u001b[0m \u001b[0mGetDomain\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;34m'user@domain.com'\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m",
      "\u001b[1;31mTypeError\u001b[0m: GetDomain() takes 0 positional arguments but 1 was given"
     ]
    }
   ],
   "source": [
    "# Code cell 6\n",
    "#def GetDomain(?):\n",
    "#    return ?.?()[-1]\n",
    "GetDomain('user@domain.com')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### 8) Cree una función básica, findInternet(), que dé una devolución de True si la palabra 'Internet' se incluye en la cadena de entrada. No se preocupe por los casos de perímetro como la puntuación que se asocia con la palabra, pero tenga en cuenta el uso de mayúsculas. (Sugerencia: vea https://docs.python.org/2/reference/expressions.html#in)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "metadata": {},
   "outputs": [
    {
     "ename": "AttributeError",
     "evalue": "'bool' object has no attribute 'split'",
     "output_type": "error",
     "traceback": [
      "\u001b[1;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[1;31mAttributeError\u001b[0m                            Traceback (most recent call last)",
      "\u001b[1;32m<ipython-input-17-8276af65af2c>\u001b[0m in \u001b[0;36m<module>\u001b[1;34m\u001b[0m\n\u001b[0;32m      2\u001b[0m \u001b[1;31m#def findInternet(?):\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m      3\u001b[0m     \u001b[1;31m#return 'internet' in ?.lower().split()\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m----> 4\u001b[1;33m \u001b[0mfindInternet\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;34m'The Internet Engineering Task Force was created in 1986'\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m",
      "\u001b[1;32m<ipython-input-16-a7ee2bf17e46>\u001b[0m in \u001b[0;36mfindInternet\u001b[1;34m(internet)\u001b[0m\n\u001b[0;32m      1\u001b[0m \u001b[1;31m# Code cell 7\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m      2\u001b[0m \u001b[1;32mdef\u001b[0m \u001b[0mfindInternet\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0minternet\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m:\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m----> 3\u001b[1;33m     \u001b[1;32mreturn\u001b[0m \u001b[0minternet\u001b[0m \u001b[1;32min\u001b[0m \u001b[1;32mTrue\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0msplit\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m\u001b[0;32m      4\u001b[0m \u001b[0mfindInternet\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;34m'The Internet Engineering Task Force was created in 1986'\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n",
      "\u001b[1;31mAttributeError\u001b[0m: 'bool' object has no attribute 'split'"
     ]
    }
   ],
   "source": [
    "# Code cell 7\n",
    "#def findInternet(?):\n",
    "    #return 'internet' in ?.lower().split()\n",
    "findInternet('The Internet Engineering Task Force was created in 1986')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### 9) Cree una función, countIoT(), que cuente la cantidad de veces que la palabra \"IdT\" aparece en una cadena.  Ignore los casos de perímetro pero tenga en cuenta el uso de mayúsculas."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Code cell 8\n",
    "def countIoT(st):\n",
    "#    \n",
    "#\n",
    "#\n",
    "#\n",
    " return count\n",
    "countIoT('I don\\'t know how to spell IoT ! Is it IoT or iot ? What does iot mean anyway?')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### 10) Utilice las expresiones lambda y la función filter() para filtrar las palabras de una lista que no comiencen con la letra 'd'. Por ejemplo:\n",
    "\n",
    "    sec = [“datos”, “sal”, “diario”, “gato”, “perro”]\n",
    "\n",
    "debe ser filtrado a:\n",
    "\n",
    "    ['datos', 'diario']"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 23,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      " ['data', 'dairy', 'dog']\n"
     ]
    }
   ],
   "source": [
    "# Code cell 9\n",
    "sec = ['data','salt' ,'dairy','cat', 'dog']\n",
    "sec1= list(filter(lambda x: x[0] == \"d\", sec))\n",
    "print(\"\",sec1)\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### 11) Utilice las expresiones lambda y la función map() para convertir una lista de palabras a mayúsculas. Por ejemplo:"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "sec = [“datos”, “sal”, “diario”, “gato”, “perro”]\n",
    "\n",
    "debe ser:\n",
    "\n",
    "   [“DATOS”, “SAL”, “DIARIO”, “GATO”, “PERRO”]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 26,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      " ['DATOS', 'SAL', 'DIARIO', 'GATO', 'PERRO']\n"
     ]
    }
   ],
   "source": [
    "# Code cell 10\n",
    "sec = ['datos', 'sal', 'diario', 'gato', 'perro'];\n",
    "nuevo= list(map(lambda x:x.upper(),sec))\n",
    "print(\"\",nuevo)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "12) Imagine un termostato inteligente conectado a la puerta que pueda detectar, además de la temperatura, el momento en el que las personas entran o salen de la casa. \n",
    "Escriba una función que, cuando la temperatura sea inferior a 20 ºC y haya personas en la casa (codificado como valor booleano que se envía como parámetro a la función), inicie la calefacción mediante la devolución de la cadena \"calefacción encendida\". Cuando la temperatura llegue a 23 grados o no haya personas en la casa, la función devuelve la cadena \"calefacción apagada\". Cuando no se cumpla ninguna de estas condiciones, la función es \"No hacer nada\"."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "# Code cell 11\n",
    "def smart_thermostat(temp, people_in):\n",
    "    ...\n",
    "    return command"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Code cell 12\n",
    " Verify smart_thermostat()\n",
    "smart_thermostat(21,True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Code cell 13\n",
    " Verify smart_thermostat()\n",
    "smart_thermostat(21,False)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### 13) La función zip(list1, list2) devuelve una lista de tuplas, donde la tupla i-th contiene el elemento i-th de cada una de las listas de argumento. Utilice la función zip para crear la siguiente lista de tuplas:"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "'comprimido = [(“Estacionamiento”, -1), (“Negocios”, 0), (“Área de restaurantes”, 1), (“oficinas”, 2)]'"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 28,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[('Parking', -1), ('Shops', 0), ('Food Court', 1), ('Offices', 2)]\n"
     ]
    }
   ],
   "source": [
    "# Code cell 14\n",
    "floor_types = ['Parking', 'Shops', 'Food Court', 'Offices']\n",
    "floor_numbers = range(-1,3)\n",
    "zipped = list(zip(floor_types, floor_numbers)) \n",
    "print(zipped)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### 14) Utilice la función zip y dict() para crear un diccionario, elevator_dict, donde las teclas sean los tipos de piso y los valores sean el número correspondiente del piso, de modo que:\n",
    "elevator_dict[- 1] = “Estacionamiento”"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 47,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "{'elevator_dict [-1]': 'Parking', 'elevator_dict [0]': 'Shops', 'elevator_dict [1]': 'Food Court', 'elevator_dict [2]': 'Offices'}\n"
     ]
    }
   ],
   "source": [
    "# Code cell 15\n",
    "floor_types = ['Parking', 'Shops', 'Food Court', 'Offices']\n",
    "part2 = ['elevator_dict [-1]', 'elevator_dict [0]', 'elevator_dict [1]','elevator_dict [2]']\n",
    "elevator_dict = dict(zip(part2, floor_types))\n",
    "print(elevator_dict)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 43,
   "metadata": {
    "scrolled": true
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "'Parking'"
      ]
     },
     "execution_count": 43,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# Code cell 16\n",
    "# Verify elevator_dict[-1]\n",
    "elevator_dict[-1]"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### 15) Cree una clase de 'Ascensor'. El constructor acepta la lista de cadenas 'floor_types' y la lista de números enteros 'floor_numbers'. La clase implementa los métodos 'ask_which_floor' y 'go_to_floor'. La salida de estos métodos debe verse de la siguiente manera:\n",
    "`floor_types = ['Estacionamiento', 'Negocios', 'Área de restaurantes', 'Oficinas']\n",
    "floors_numbers = rango(-1,4)\n",
    "\n",
    "el = Elevador(floor_numbers, floor_types)\n",
    "\n",
    "el.go_to_floor(1)`\n",
    "\n",
    "`¡Vaya al piso del área de restaurantes!`\n",
    "\n",
    "`el.go_to_floor(-2)`\n",
    "\n",
    "`En este edificio está el piso número -2.`\n",
    "\n",
    "`El.ask_which_floor('Oficinas')`\n",
    "\n",
    "`El piso de oficinas es el número: 2`\n",
    "\n",
    "`El.ask_which_floor('Piscina')`\n",
    "\n",
    "`No hay ningún piso con piscina en este edificio.`"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 77,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Code cell 17\n",
    "class Elevator:\n",
    "    \n",
    "    def __init__(self, floor_numbers, floor_types):\n",
    "        self._floor_numbers = floor_numbers\n",
    "        self._floor_types = floor_types\n",
    "        self._number_to_type_dict = dict(zip(floor_numbers, floor_types)) \n",
    "        self._type_to_number_dict = dict(zip(floor_types, floor_numbers)) \n",
    "        \n",
    "    def ask_which_floor(self, floor_type):    \n",
    "        if floor_type in self._floor_types:\n",
    "            print('The {} floor is the number: {}.'.format(floor_type, self._type_to_number_dict[floor_type]))\n",
    "        else:\n",
    "            print('There is no {} floor in this building.'.format(floor_type))\n",
    "    \n",
    "    #def go_to_floor(self, floor_number):\n",
    "    "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 78,
   "metadata": {},
   "outputs": [
    {
     "ename": "AttributeError",
     "evalue": "'Elevator' object has no attribute 'go_to_floor'",
     "output_type": "error",
     "traceback": [
      "\u001b[1;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[1;31mAttributeError\u001b[0m                            Traceback (most recent call last)",
      "\u001b[1;32m<ipython-input-78-bc62f0dd13bc>\u001b[0m in \u001b[0;36m<module>\u001b[1;34m\u001b[0m\n\u001b[0;32m      1\u001b[0m \u001b[1;31m# Verify code cell 18\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m      2\u001b[0m \u001b[0mel\u001b[0m \u001b[1;33m=\u001b[0m \u001b[0mElevator\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mfloor_numbers\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0mfloor_types\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m----> 3\u001b[1;33m \u001b[0mel\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mgo_to_floor\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;36m1\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m",
      "\u001b[1;31mAttributeError\u001b[0m: 'Elevator' object has no attribute 'go_to_floor'"
     ]
    }
   ],
   "source": [
    "# Verify code cell 18\n",
    "el = Elevator(floor_numbers, floor_types)\n",
    "el.go_to_floor(1)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Verify code cell 19\n",
    "el.go_to_floor(-2)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "scrolled": true
   },
   "outputs": [],
   "source": [
    "# Verify code cell 20\n",
    "el.ask_which_floor('Offices')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Verify code cell 21\n",
    "el.ask_which_floor('Swimming Pool')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# ¡Excelente trabajo!"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": true
   },
   "source": [
    "<font size='0.5'>© 2017 Cisco y/o sus filiales. Todos los derechos reservados. Este documento es información pública de Cisco.<font>"
   ]
  }
 ],
 "metadata": {
  "anaconda-cloud": {},
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.4"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 1
}
